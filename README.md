Отчёт по Лабораторной Работе №2 на тему "STL"

В заданиях 1, 2, 3 элементами контейнеров являются целые числа. Для заполнения контейнера
использовать итератор и конструктор соответствующего контейнера, для вывода элементов
использовать итератор (для вывода элементов в обратном порядке использовать обратные
итераторы, возвращаемые функциями-членами rbegin и rend).
В задании 4 обработка данных выполняется без использования контейнеров. Если алгоритм требует
применения функционального объекта, следует использовать лямбда-выражения. Использовать
итераторы istream_iterator и ostream_iterator.
Если в заданиях 5, 6, 7, 8, 9, 10 тип элементов контейнера не указан, то предполагается, что
элементами являются целые числа.

Задание 1. Заполнение и доступ к элементам. Обратные итераторы.
Дан набор целых чисел с четным количеством элементов. Заполнить дек D исходными числами,
вывести первую половину элементов дека D в обратном порядке, а затем — вторую половину (также в обратном порядке).

Алгоритм решения
Ввод количества чисел:

Запросить у пользователя чётное положительное число.
Проверить ввод: число должно быть целым, положительным и чётным.
Ввод элементов:

В цикле по количеству чисел запрашивать каждое число.
Проверять правильность ввода.
Обработка данных:

Разделить исходный deque на две половины.
Вывести первую половину элементов в обратном порядке.
Вывести вторую половину элементов в обратном порядке.
Вывод результатов.

Структура кода
Функция read_integer(int&)
Ввод и проверка входных данных для каждого числа или количества чисел.

Функция input_numbers(std::deque<int>&)
Ввод количества элементов и самих элементов с проверками.

Функция process_and_display(const std::deque<int>&)
Обработка и вывод данных: разделение и обратный порядок.

main()
Координатор работы программы: вызов функций ввода и обработки.

Тесты 

Тест 1
Ввод:

Введите чётное положительное число: 4
Введите число #1: 1
Введите число #2: 2
Введите число #3: 3
Введите число #4: 4

Ожидаемый вывод:

Первая половина в обратном порядке:
2 1
Вторая половина в обратном порядке:
4 3

Тест 2
Ввод:

Введите чётное положительное число: 6
Введите число #1: -1
Введите число #2: 0
Введите число #3: 5
Введите число #4: 6
Введите число #5: -7
Введите число #6: 8

Ожидаемый вывод:

Первая половина в обратном порядке:
0 -1
Вторая половина в обратном порядке:
8 7

Тест 3
Ввод:

Введите чётное положительное число: 2
Введите число #1: 10
Введите число #2: 20

Ожидаемый вывод:

Первая половина в обратном порядке:
10
Вторая половина в обратном порядке:
20

Задание 2. Вставка элементов
Дан вектор V. Вставить после каждого элемента исходного вектора число − 1. Использовать
функцию-член insert в цикле с параметром-итератором.
Указание. Организуйте перебор элементов вектора в цикле с параметром-итератором i.
Вставку выполняйте впозицию ++i, обязательно присваивая параметру i значение, возвращаемое функцией-членом insert.

Алгоритм решения

Ввод данных:

Запрашивается количество элементов вектора
Поочередно вводятся все элементы вектора с проверкой корректности ввода
Все элементы сохраняются в вектор V
Вставка элементов -1:
Используется итератор для перебора исходного вектора
После каждого элемента вставляется число -1
Ключевой момент: итератор корректно обновляется после вставки, чтобы продолжить обход
Вывод результата:
Выводится результирующий вектор с вставленными элементами -1
Особенности алгоритма:
После вставки элемента -1, функция insert возвращает итератор на вставленный элемент
Итератор автоматически увеличивается, чтобы перейти к следующему оригинальному элементу
Это предотвращает бесконечный цикл и корректно обрабатывает изменение размера вектора

Структура кода
Код состоит из трех основных функций:
read_integer(int& value) (вспомогательная)
Назначение: Безопасное чтение целого числа из потока ввода
Особенности:
Проверяет корректность ввода
Сбрасывает состояние потока при ошибке
Очищает буфер ввода
fill_vector(std::vector<int>& vec) (ввод данных)
Назначение: Заполнение вектора пользовательскими данными
Особенности:
Запрашивает количество элементов с проверкой
В цикле заполняет вектор элементами с проверкой ввода
insert_after_each_element(std::vector<int>& vec) (основная логика)
Назначение: Вставка числа -1 после каждого элемента вектора
Особенности:
Использует итератор для перебора элементов
Применяет функцию-член insert с правильной обработкой возвращаемого значения
Следует указанию из задания об обновлении итератора
main() (управляющая функция)
Координирует вызов всех функций
Выводит финальный результат

Тесты корректности работы

Тест 1: Стандартный случай
Входные данные:
Введите количество элементов вектора: 3
Введите 3 элементов:
Элемент #1: 10
Элемент #2: 20
Элемент #3: 30
Ожидаемый вывод:


Результирующий вектор:
10 -1 20 -1 30 -1
Объяснение: После каждого из трех элементов (10, 20, 30) вставляется число -1.

Тест 2: Вектор из одного элемента
Входные данные:
Введите количество элементов вектора: 1
Введите 1 элементов:
Элемент #1: 100
Ожидаемый вывод:


Результирующий вектор:
100 -1
Объяснение: После единственного элемента 100 вставляется число -1.

Тест 3: Пустой вектор (граничный случай)
Входные данные:
Введите количество элементов вектора: 0
Ожидаемый вывод:

Результирующий вектор:
Объяснение: Пустой вектор остается пустым, так как нет элементов, после которых можно вставить -1.

Тест 4: Отрицательные числа в исходном векторе
Входные данные:

Введите количество элементов вектора: 2
Введите 2 элементов:
Элемент #1: -5
Элемент #2: 5
Ожидаемый вывод:

Результирующий вектор:
-5 -1 5 -1
Объяснение: После каждого элемента (-5 и 5) вставляется число -1, независимо от знака исходных элементов.

Задание 3. Удаление элементов
Дан дек D с нечетным количеством элементов N (≥3). Удалить средний элемент дека.
Использовать функцию-член erase

Алгоритм решения
Ввод данных:
Запрашивается количество элементов дека (N)
Проверяется, что N ≥ 3 и нечетное
Поочередно вводятся все элементы дека с проверкой корректности ввода
Элементы добавляются в конец дека
Определение среднего элемента:
Вычисляется размер дека: N = d.size()
Для нечетного N средний элемент находится по индексу N / 2
Пример: если N = 5, то индексы: 0, 1, 2, 3, 4 → средний индекс = 5/2 = 2
Удаление среднего элемента:
Создается итератор, указывающий на средний элемент: d.begin() + middle_index
Используется функция-член erase для удаления элемента по итератору
После удаления размер дека уменьшается на 1
Вывод результата:
Выводится дек после удаления среднего элемента

Структура кода
Код состоит из трех основных функций:
read_integer(int& value) (вспомогательная)
Назначение: Безопасное чтение целого числа из потока ввода
Особенности:
Проверяет корректность ввода с помощью cin.fail()
Сбрасывает состояние потока при ошибке (cin.clear())
Очищает буфер ввода от неверных данных (cin.ignore())
fill_deque(std::deque<int>& d) (ввод данных)
Назначение: Заполнение дека пользовательскими данными
Особенности:
Запрашивает количество элементов с проверкой: N ≥ 3 и нечетное
В цикле заполняет дек элементами с проверкой ввода каждого элемента
Использует push_back для добавления элементов в конец дека
remove_middle_element(std::deque<int>& d) (основная логика)
Назначение: Удаление среднего элемента дека
Особенности:
Вычисляет средний индекс: N / 2 для нечетного N
Создает итератор на средний элемент: d.begin() + middle_index
Использует функцию-член erase для удаления элемента
main() (управляющая функция)
Создает дек
Вызывает функции заполнения и удаления
Выводит результат

3. Тесты корректности работы

Тест 1: Минимальный размер (N = 3)
Входные данные:


Введите нечетное количество элементов дека (≥3): 3
Введите 3 элементов:
Элемент #1: 10
Элемент #2: 20
Элемент #3: 30

Ожидаемый вывод:
Дек после удаления среднего элемента:
10 30
Объяснение: Дек: [10, 20, 30]. Средний элемент с индексом 1 (20) удаляется. Остается [10, 30].

Тест 2: N = 5
Входные данные:

Введите нечетное количество элементов дека (≥3): 5
Введите 5 элементов:
Элемент #1: 1
Элемент #2: 2
Элемент #3: 3
Элемент #4: 4
Элемент #5: 5

Ожидаемый вывод:
Дек после удаления среднего элемента:
1 2 4 5
Объяснение: Дек: [1, 2, 3, 4, 5]. Средний элемент с индексом 2 (3) удаляется. Остается [1, 2, 4, 5].

Тест 3: N = 7
Входные данные:

Введите нечетное количество элементов дека (≥3): 7
Введите 7 элементов:
Элемент #1: 100
Элемент #2: 200
Элемент #3: 300
Элемент #4: 400
Элемент #5: 500
Элемент #6: 600
Элемент #7: 700

Ожидаемый вывод:

Дек после удаления среднего элемента:
100 200 300 500 600 700
Объяснение: Дек: [100, 200, 300, 400, 500, 600, 700]. Средний элемент с индексом 3 (400) удаляется. Остается [100, 200, 300, 500, 600, 700].

Задание 4. Итераторы и алгоритмы.
Дана строка name и целое число K (> 0). Записать в текстовый файл с именем name K символов
«*». Использовать алгоритм fill_n

Алгоритм решения
Ввод данных:
Запрашивается имя файла (строка name)
Запрашивается целое число K > 0
Выполняется проверка корректности ввода K
Открытие файла:
Создается объект ofstream для записи в файл с указанным именем
Проверяется успешность открытия файла
Запись символов в файл:
Используется алгоритм fill_n для записи K символов '*'
fill_n заполняет выходную последовательность указанным значением заданное количество раз
В качестве выходного итератора используется ostreambuf_iterator<char>(ofs), который записывает символы непосредственно в поток вывода файла
Завершение работы:
Закрывается файл
Выводится сообщение об успешном выполнении

Структура кода
Код состоит из одной функции main() с четкой последовательностью действий:

Ввод данных:
Считывание имени файла в строку name
Считывание числа K с проверкой корректности:
Проверка на сбой потока ввода (cin.fail())
Проверка условия K > 0
Очистка буфера ввода при некорректном вводе
Работа с файлом:
Создание объекта ofstream для записи
Проверка успешности открытия файла
Использование fill_n для записи символов:
std::ostreambuf_iterator<char>(ofs) - итератор вывода в поток файла
K - количество символов для записи
'*' - символ для заполнения
Закрытие файла
Вывод результата:
Информационное сообщение о количестве записанных символов

3. Тесты корректности работы

Тест 1: Стандартный случай
Входные данные:

Введите имя файла: stars.txt
Введите число K (> 0): 5

Ожидаемый вывод:

Записано 5 символов '*' в файл stars.txt.
Содержимое файла stars.txt:
*****

Тест 2: Большое количество символов
Входные данные:

Введите имя файла: many_stars.txt
Введите число K (> 0): 10

Ожидаемый вывод:

Записано 10 символов '*' в файл many_stars.txt.
Содержимое файла many_stars.txt:
**********

Тест 3: Некорректный ввод числа K с последующим исправлением
Входные данные:

Введите имя файла: test.txt
Введите число K (> 0): -5
Некорректный ввод. Введите число K (> 0): 0
Некорректный ввод. Введите число K (> 0): abc
Некорректный ввод. Введите число K (> 0): 3

Ожидаемый вывод:
Записано 3 символов '*' в файл test.txt.
Содержимое файла test.txt:
***

Задание 5. Алгоритмы поиска
Даны вектор V и список L; вектор V имеет четное количество элементов. Продублировать
последний элемент списка, совпадающий с каким-либо элементом из первой половины
исходного вектора. Если список не содержит требуемых элементов, то не изменять его.
Использовать алгоритм find_first_of и функцию-член insert для списка

Алгоритм решения
Ввод вектора: Получаем четное количество элементов и сами элементы.
Ввод списка: Получаем количество элементов списка и сами элементы.
Поиск совпадений:
Определяем первую половину вектора (первые n/2 элементов)
Проходим по всем элементам списка от начала до конца
Для каждого элемента списка проверяем, есть ли он в первой половине вектора
Запоминаем ПОСЛЕДНЕЕ найденное совпадение
Дублирование: Если нашли совпадение, вставляем копию элемента перед ним.
Вывод: Отображаем измененный список.
Ключевой момент: Используем std::find для поиска каждого элемента списка в первой половине вектора, а не find_first_of, так как find_first_of находит только первое совпадение, а нам нужно найти последнее.

2. Структура кода
Ввод данных: Получение вектора и списка от пользователя с проверкой четности размера вектора.
Поиск последнего совпадения: Линейный проход по списку с использованием std::find для поиска в первой половине вектора.
Дублирование: Использование insert для вставки копии элемента.
Вывод результата: Отображение итогового списка.

3. Тесты корректности работы

Тест 1: Простой случай с одним совпадением
Входные данные:

Введите четное количество элементов для вектора: 6
Введите 6 элементов вектора:
1 2 3 4 5 6
Введите количество элементов для списка: 4
Введите 4 элементов списка:
7 8 2 9

Ожидаемый вывод:

Дублирован элемент: 2
Итоговый список: 7 8 2 2 9


Тест 2: Несколько совпадений, выбираем последнее
Входные данные:

Введите четное количество элементов для вектора: 4
Введите 4 элементов вектора:
10 20 30 40
Введите количество элементов для списка: 5
Введите 5 элементов списка:
10 5 20 5 30

Ожидаемый вывод:

Дублирован элемент: 20
Итоговый список: 10 5 20 20 5 30


Тест 3: Нет совпадений
Входные данные:

Введите четное количество элементов для вектора: 4
Введите 4 элементов вектора:
1 2 3 4
Введите количество элементов для списка: 3
Введите 3 элементов списка:
5 6 7

Ожидаемый вывод:

Совпадений не найдено, список не изменен
Итоговый список: 5 6 7

Задание 6. Базовые модифицирующие алгоритмы. Итераторы вставки.
Дано число K (0 <K< 10) и списки L1 и L2, каждый из которых содержит не менее 10 элементов.
Выполнить для списка L1 циклический сдвиг элементов вправо на K позиций, а для списка L2 —
циклический сдвиг влево на K позиций. Использовать алгоритм rotate и функцию advance

Алгоритм решения
Ввод K: Получаем число K с проверкой (0 < K < 10).
Ввод списков: Получаем два списка L1 и L2, каждый не менее 10 элементов.
Циклический сдвиг вправо для L1:
Используем std::advance для перемещения итератора на (размер - K) позиций от начала
Применяем std::rotate с этим итератором как средней точкой
Формула: rotate(begin, begin + (size - K), end)
Циклический сдвиг влево для L2:
Используем std::advance для перемещения итератора на K позиций от начала
Применяем std::rotate с этим итератором как средней точкой
Формула: rotate(begin, begin + K, end)
Вывод результатов: Отображаем оба преобразованных списка.

2. Структура кода
Ввод данных: Получение K и двух списков с проверкой условий.
Обработка L1: Циклический сдвиг вправо с использованием advance и rotate.
Обработка L2: Циклический сдвиг влево с использованием advance и rotate.
Вывод: Отображение исходных и преобразованных списков.

3. Тесты корректности работы

Тест 1: K=3, простые последовательности
Входные данные:

Введите число K (0 < K < 10): 3
Введите количество элементов для списка L1 (не менее 10): 10
Введите 10 элементов списка L1:
1 2 3 4 5 6 7 8 9 10
Введите количество элементов для списка L2 (не менее 10): 10
Введите 10 элементов списка L2:
10 20 30 40 50 60 70 80 90 100

Ожидаемый вывод:

Исходный список L1: 1 2 3 4 5 6 7 8 9 10
Исходный список L2: 10 20 30 40 50 60 70 80 90 100

После циклического сдвига вправо на 3 позиций:
Список L1: 8 9 10 1 2 3 4 5 6 7

После циклического сдвига влево на 3 позиций:
Список L2: 40 50 60 70 80 90 100 10 20 30


Тест 2: K=1, минимальный сдвиг
Входные данные:

Введите число K (0 < K < 10): 1
Введите количество элементов для списка L1 (не менее 10): 10
Введите 10 элементов списка L1:
1 2 3 4 5 6 7 8 9 10
Введите количество элементов для списка L2 (не менее 10): 10
Введите 10 элементов списка L2:
10 20 30 40 50 60 70 80 90 100

Ожидаемый вывод:

Исходный список L1: 1 2 3 4 5 6 7 8 9 10
Исходный список L2: 10 20 30 40 50 60 70 80 90 100

После циклического сдвига вправо на 1 позиций:
Список L1: 10 1 2 3 4 5 6 7 8 9

После циклического сдвига влево на 1 позиций:
Список L2: 20 30 40 50 60 70 80 90 100 10

Тест 3: K=5, средний сдвиг

Входные данные:

Введите число K (0 < K < 10): 5
Введите количество элементов для списка L1 (не менее 10): 12
Введите 12 элементов списка L1:
1 2 3 4 5 6 7 8 9 10 11 12
Введите количество элементов для списка L2 (не менее 10): 12
Введите 12 элементов списка L2:
12 24 36 48 60 72 84 96 108 120 132 144

Ожидаемый вывод:

Исходный список L1: 1 2 3 4 5 6 7 8 9 10 11 12
Исходный список L2: 12 24 36 48 60 72 84 96 108 120 132 144

После циклического сдвига вправо на 5 позиций:
Список L1: 8 9 10 11 12 1 2 3 4 5 6 7

После циклического сдвига влево на 5 позиций:
Список L2: 72 84 96 108 120 132 144 12 24 36 48 60

Задание 7. Сортировка и слияние
Дан вектор V, содержащий не менее 3 элементов. Определить значения трех конечных
элементов вектора после того, как вектор будет отсортирован (по возрастанию) и вывести их в
порядке убывания. Использовать один вызов алгоритма partial_sort с параметром —
функциональным объектом greater и алгоритм copy для вывода требуемых элементов.

Алгоритм решения
Ввод вектора: Получаем вектор с не менее чем 3 элементами.
Частичная сортировка: Используем std::partial_sort с функциональным объектом std::greater<int>():
Сортируем только первые 3 позиции вектора
Используем std::greater<int>() для сортировки по убыванию
Результат: первые три элемента становятся тремя наибольшими элементами всего вектора, отсортированными по убыванию
Вывод результата: Используем std::copy с std::ostream_iterator для вывода первых трех элементов.

2. Структура кода
Ввод данных: Получение вектора с проверкой минимального размера.
Обработка: Один вызов partial_sort с использованием greater<int>.
Вывод: Использование copy с ostream_iterator для вывода результата.

3. Тесты корректности работы

Тест 1: Простой случай
Входные данные:

Введите количество элементов для вектора (не менее 3): 5
Введите 5 элементов вектора:
10 20 30 40 50
Ожидаемый вывод:

Исходный вектор: 10 20 30 40 50
Три наибольших элемента после сортировки (по убыванию): 50 40 30

Тест 2: Случайные числа
Входные данные:

Введите количество элементов для вектора (не менее 3): 7
Введите 7 элементов вектора:
5 2 9 1 8 3 7

Ожидаемый вывод:

Исходный вектор: 5 2 9 1 8 3 7
Три наибольших элемента после сортировки (по убыванию): 9 8 7

Тест 3: С повторяющимися значениями
Входные данные:

Введите количество элементов для вектора (не менее 3): 6
Введите 6 элементов вектора:
5 5 3 8 8 1

Ожидаемый вывод:

Исходный вектор: 5 5 3 8 8 1
Три наибольших элемента после сортировки (по убыванию): 8 8 5

Задание 8. Численные алгоритмы.
Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего
арифметического для всех пар соседних элементов исходного списка (количество элементов
вектора V должно быть на 1 меньше количества элементов списка L). Например, для исходного
списка 1, 3, 4, 6 полученный вектор должен содержать значения 2.0, 3.5, 5.0. Использовать
алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также
функцию-член erase для вектора V.

Алгоритм решения
Ввод списка: Получаем список L с не менее чем 2 элементами.
Использование adjacent_difference:
Создаем пользовательскую операцию (лямбда-функцию), которая вычисляет сумму двух соседних элементов
Применяем std::adjacent_difference с этой операцией к списку L
Результат: вектор сумм пар соседних элементов
Корректировка результата:
Первый элемент результата adjacent_difference - это копия первого элемента списка
Удаляем его с помощью erase
Вычисление средних:
Делим каждую сумму на 2.0, получая среднее арифметическое
Сохраняем в результирующий вектор V
Вывод результата: Отображаем вектор средних значений.

2. Структура кода
Ввод данных: Получение списка с проверкой минимального размера.
Обработка с adjacent_difference:
Использование adjacent_difference с пользовательской операцией сложения
Удаление первого элемента с помощью erase
Вычисление средних: Преобразование сумм в средние арифметические.
Вывод: Отображение вектора средних значений.

3. Тесты корректности работы

Тест 1: Пример из задания
Входные данные:

Введите количество элементов для списка: 4
Введите 4 элементов списка (целые числа):
1 3 4 6

Ожидаемый вывод:

Исходный список L: 1 3 4 6

Вектор V (средние арифметические соседних элементов):
2.00, 3.50, 5.00

Тест 2: Пять элементов

Входные данные:

Введите количество элементов для списка: 5
Введите 5 элементов списка (целые числа):
10 20 30 40 50
Ожидаемый вывод:

Исходный список L: 10 20 30 40 50

Вектор V (средние арифметические соседних элементов):
15.00, 25.00, 35.00, 45.00

Тест 3: С отрицательными числами
Входные данные:

Введите количество элементов для списка: 3
Введите 3 элементов списка (целые числа):
-5 0 5
Ожидаемый вывод:

Исходный список L: -5 0 5

Вектор V (средние арифметические соседних элементов):
-2.50, 2.50

Задание 9. Множества.
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N,
в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать
алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе
вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I =
1, …, N.

Алгоритм решения
Ввод данных:
Вектор V0
Число N (> 0)
N векторов V1..VN с проверкой, что их размер ≥ размера V0
Подготовка данных:
Создаем множество setV0 из элементов вектора V0 (автоматически удаляет дубликаты и сортирует)
Проверка каждого вектора:
Для каждого вектора Vi создаем множество setVi (удаляем дубликаты, сортируем)
Используем алгоритм std::includes для проверки, содержит ли setVi все элементы setV0
std::includes работает с отсортированными диапазонами и проверяет, является ли один набор подмножеством другого
Подсчет результатов:
Увеличиваем счетчик, если текущий вектор содержит все элементы V0

2. Структура кода
Ввод V0: Получение исходного вектора
Ввод N: Получение количества проверяемых векторов
Ввод векторов V1..VN: Получение N векторов с проверкой размеров
Создание setV0: Преобразование V0 в множество (уникальные отсортированные элементы)
Цикл проверки: Для каждого вектора создаем множество и используем includes для проверки включения
Вывод результатов: Отображение исходных данных и результата

3. Тесты корректности работы

Тест 1: Все векторы содержат V0
Входные данные:

Введите количество элементов вектора V0: 3
Введите 3 элементов вектора V0:
1 2 3

Введите число N (> 0): 2

Введите количество элементов вектора V1: 5
Введите 5 элементов вектора V1:
1 2 3 4 5

Введите количество элементов вектора V2: 4
Введите 4 элементов вектора V2:
3 1 2 5

Ожидаемый вывод:

РЕЗУЛЬТАТЫ 
Вектор V0: 1 2 3
Уникальные элементы V0: 1 2 3

Количество векторов V1..VN, содержащих все элементы V0: 2

Тест 2: Не все векторы содержат V0
Входные данные:

Введите количество элементов вектора V0: 2
Введите 2 элементов вектора V0:
4 5

Введите число N (> 0): 3

Введите количество элементов вектора V1: 4
Введите 4 элементов вектора V1:
1 2 3 4

Введите количество элементов вектора V2: 3  
Введите 3 элементов вектора V2:
4 5 6

Введите количество элементов вектора V3: 5
Введите 5 элементов вектора V3:
5 5 4 7 8

Ожидаемый вывод:

РЕЗУЛЬТАТЫ 
Вектор V0: 4 5
Уникальные элементы V0: 4 5

Количество векторов V1..VN, содержащих все элементы V0: 2

Задание 10. Отображения.
Дан вектор V, элементами которого являются английские слова, набранные заглавными
буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести
все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной
этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей
буквы. Использовать вспомогательное отображение M, ключами которого являются начальные
буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении
отображения M не использовать условные конструкции (достаточно операций индексирования
[], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении
отображения M) и элементы отображения M (при выводе полученных результатов) перебирать
в цикле с параметром-итератором соответствующего контейнера

Алгоритм решения
Ввод данных:
Получаем количество английских слов
Заполняем вектор V этими словами (все буквы заглавные)
Создание отображения M:
Используем std::map<char, int> для хранения пар: начальная буква → суммарная длина слов
Для каждого слова в векторе V:
Извлекаем первую букву слова
Используем оператор [] для доступа к значению в отображении по ключу (начальной букве)
Если такой ключ еще не существует, оператор [] создает его с значением 0
Добавляем длину текущего слова к существующему значению
Вывод результатов:
Используем итератор для перебора элементов отображения M
Отображение std::map автоматически сортирует ключи (буквы) в алфавитном порядке
Для каждой пары (буква, суммарная длина) выводим их на экран

2. Структура кода
Ввод вектора V: Получение английских слов от пользователя
Создание отображения M:
Используем std::map<char, int> для хранения результатов
Заполняем только операциями [], += и size() (без условных конструкций)
Вывод результатов:
Используем итератор для перебора отображения
Выводим буквы в алфавитном порядке с суммарными длинами

3. Тесты корректности работы

Тест 1: Разные начальные буквы
Входные данные:

Введите количество английских слов (заглавные буквы): 5
Введите 5 английских слов (только заглавные буквы):
APPLE BANANA CHERRY DATE EGG
Ожидаемый вывод:

Исходный вектор слов:
APPLE BANANA CHERRY DATE EGG 

РЕЗУЛЬТАТЫ 
Буква и суммарная длина слов, начинающихся с этой буквы:
A 5
B 6
C 6
D 4
E 3
Объяснение:

A: APPLE (5 букв) → 5

B: BANANA (6 букв) → 6

C: CHERRY (6 букв) → 6

D: DATE (4 буквы) → 4

E: EGG (3 буквы) → 3

Тест 2: Слова с одинаковыми начальными буквами
Входные данные:

Введите количество английских слов (заглавные буквы): 6
Введите 6 английских слов (только заглавные буквы):
CAT CAR COW DOG DUCK DEER
Ожидаемый вывод:

Исходный вектор слов:
CAT CAR COW DOG DUCK DEER 

РЕЗУЛЬТАТЫ 
Буква и суммарная длина слов, начинающихся с этой буквы:
C 10
D 12

Тест 3: Слова с повторяющимися начальными буквами
Входные данные:

Введите количество английских слов (заглавные буквы): 7
Введите 7 английских слов (только заглавные буквы):
HELLO HI HOW ARE YOU AND ANIMAL
Ожидаемый вывод:

Исходный вектор слов:
HELLO HI HOW ARE YOU AND ANIMAL 

РЕЗУЛЬТАТЫ 
Буква и суммарная длина слов, начинающихся с этой буквы:
A 8
H 11
Y 3
